;;;;
;;;; Copyright (C) 2002-2005 John A.R. Williams <J.A.R.Williams@jarw.org.uk>
;;;; Released under the GNU General Public License (GPL)
;;;; See <http://www.gnu.org/copyleft/gpl.html> for license details

(in-package :docutils.transform)

(defmethod transforms((reader docutils:reader))
  "Default transforms for standard reader"
  '(decorations final-checks filter-messages))

(defclass decorations(transform)
  ()
  (:default-initargs :priority 820)
  (:documentation
   "Populate a document's decoration element (header, footer)."))

(defmethod transform((transform decorations))
  (let ((header (generate-header transform))
        (footer (generate-footer transform)))
    (when (or header footer)
      (let ((decoration (make-node 'docutils.nodes:decoration))
            (document (document (node transform))))
        (when header (add-child decoration header))
        (when footer (add-child decoration footer))
        (add-child document decoration
                   (position-if-not
                    #'(lambda(n) (and (typep n 'docutils.nodes::predecorative)
                                      (not (typep n 'docutils.nodes::target))))
                    (slot-value document 'docutils::children)))))))

(defgeneric generate-header(transform)
  (:documentation "Generate the header and add to document")
  (:method(transform) (declare (ignore transform))  nil))

(defun relative-path(source destination)
  (assert (not (wild-pathname-p source)))
  (when (wild-pathname-p destination)
    (return-from relative-path destination))
  (let* ((srcdir (pathname-directory source))
         (destdir (pathname-directory destination))
         (p (mismatch srcdir destdir :test #'equal)))
    (unless p
      (return-from relative-path
        (make-pathname :name (pathname-name destination)
                       :type (pathname-type destination))))
    (setf srcdir (subseq srcdir p)
          destdir (subseq destdir p))
    (make-pathname :directory
                   `(:relative
                     ,@(mapcar #'(lambda(a) (declare (ignore a)) :up) srcdir)
                     ,@destdir)
                   :name (pathname-name destination)
                   :type (pathname-type destination))))

(defgeneric generate-footer(transform)
  (:documentation "Generate the footer and add to document for this transform")
  (:method (transform)
    (let ((document (document (node transform))))
      (let ((text nil)
            (source
             (or (setting :source-url document)
                 (and (setting :source document)
                      (setting :source-link document)
                      (relative-path (setting :source document)
                                     (setting :destination document))))))
        (flet((add-text(&rest args) (setf text (nconc text args))))
          (when source
            (add-text
             (make-node 'docutils.nodes:reference
                        "View document source" :refuri source)
             #\newline))
          (when (setting :datestamp document)
            (add-text
             (format nil "Generated on : ~A .~%"
                     (format-output 'date (get-universal-time) :fmt
                                    (setting :datestamp document) ))))
          (when (setting :generator document)
            (add-text
             (format nil "Generated by cl-docutils ~{~D.~D.~D~} from "
                     docutils::*revision*)
             (make-node 'docutils.nodes:reference "restructured text"
                        :refuri "http://docutils.sourceforge.net/rst.html")
             " source.
"))
          (when text
            (let ((footer (make-node 'docutils.nodes:footer)))
              (add-child footer (make-node 'docutils.nodes:paragraph text))
              footer )))))))

(defclass filter-messages(transform)
  ()
  (:default-initargs :priority 870)
  (:documentation
   "Remove system messages below verbosity threshold. "))

(defmethod transform((transform filter-messages))
  (let*((document (document (node transform)))
        (level (setting :report-level document)))
    (map 'nil #'remove-node
         (collate-nodes(node document)
                       (and (typep node 'docutils.nodes::system-message)
                            (< (error-severity node) level))))))

(defclass final-checks(transform)
  ()
  (:default-initargs :priority 840)
  (:documentation
   "Perform last-minute checks and transforms.

    - Check for dangling references (incl. footnote & citation).
    - Check for illegal transitions, move transitions"))


(defmethod transform((transform final-checks))
  (let ((nameids (docutils:nameids (document (node transform)))))
    (map nil #'(lambda(n) (final-check-reference n nameids))
       (collate-nodes(node (document (node transform)))
                     (typep node 'docutils.nodes:reference)))
    (map nil #'final-check-transition
         (collate-nodes(node (document (node transform)))
                       (typep node 'docutils.nodes:transition)))))

(defun final-check-reference(node nameids)
  (let ((refname  (attribute node :refname)))
    (unless (or (resolved node) (not refname))
      (let((id (gethash refname nameids)))
        (if id
            (progn
              (rem-attribute node :refname)
              (setf (attribute node :refid) id
                    (resolved node) t))
            (progn
              (dolist (resolver *unknown-reference-resolvers*)
                (when (funcall resolver node)
                  (return-from final-check-reference)))
              (let* ((msg (report
                           :error
                           `("~:[Unknown target name ~S~;Duplicate target name: ~:*~S, cannot be used as a unique reference~]"
                             ,(gethash refname nameids) ,refname)
                           :node node))
                     (msgid (set-id msg))
                     (problematic
                      (make-node 'docutils.nodes:problematic
                                 :refid msgid
                                  (as-text node)))
                     (prbid (set-id problematic)))
                (add-backref msg prbid)
                (substitute-node problematic node))))))))

(defun final-check-transition(node)
  "Move transitions at the end of sections up the tree.  Complain on
transitions after a title, at the beginning or end of the document,
and after another transition."
  (let* ((parent (parent node))
         (index (index parent node))
         (msg
          (cond
            ((or (= 0 index)
                 (and (typep (child parent 0) 'docutils.nodes:title)
                      (or (= 1 index)
                          (and (typep (child parent 1)
                                      'docutils.nodes:subtitle)
                               (= 2 index)))))
             (assert (or (typep parent 'docutils.nodes:document)
                         (typep parent 'docutils.nodes:section)))
             (report :error
                     "Document or section may not begin with a transition"
                     :line (line node)))
            ((typep (child parent (1- index)) 'docutils.nodes:transition)
             (report :error
                     "At least one body element must separate transitions; adjacent transitions are not allowed."
                     :line (line node))))))
    (when msg
      (remove-node msg)
      (add-child parent msg index)
      (incf index))
    (unless (< index (1- (number-children parent)))
      (do*((sibling (parent node) (parent sibling))
           (index index (index (parent sibling) sibling)))
          ((< index (1- (number-children (parent sibling))))
           (remove-node node)
           (add-child (parent sibling) node (1+ index)))
        (when (typep sibling 'docutils.nodes:document)
          (let ((msg (report :error "Document may not end with a transition"
                             :line (line node))))
            (remove-node msg)
            (add-child (parent node) msg)
            (return)))))))
