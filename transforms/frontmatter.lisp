;;;;
;;;; Copyright (C) 2002-2005 John A.R. Williams <J.A.R.Williams@jarw.org.uk>
;;;; Released under the GNU General Public License (GPL)
;;;; See <http://www.gnu.org/copyleft/gpl.html> for license details
(in-package :docutils.transform)

#|
In reStructuredText_, there is no way to specify a document title
    and subtitle explicitly. Instead, we can supply the document title
    (and possibly the subtitle as well) implicitly, and use this
    two-step transform to "raise" or "promote" the title(s) (and their
    corresponding section contents) to the document level.

    1. If the document contains a single top-level section as its
       first non-comment element, the top-level section's title
       becomes the document's title, and the top-level section's
       contents become the document's immediate contents. The lone
       top-level section header must be the first non-comment element
       in the document.

       For example, take this input text::

           =================
            Top-Level Title
           =================

           A paragraph.

       Once parsed, it looks like this::

           <document>
               <section name=\"top-level title\">
                   <title>
                       Top-Level Title
                   <paragraph>
                       A paragraph.

       After running the DocTitle transform, we have::

           <document name=\"top-level title\">
               <title>
                   Top-Level Title
               <paragraph>
                   A paragraph.

    2. If step 1 successfully determines the document title, we
       continue by checking for a subtitle.

       If the lone top-level section itself contains a single
       second-level section as its first non-comment element, that
       section's title is promoted to the document's subtitle, and
       that section's contents become the document's immediate
       contents. Given this input text::

           =================
            Top-Level Title
           =================

           Second-Level Title
           ~~~~~~~~~~~~~~~~~~

           A paragraph.

       After parsing and running the Section Promotion transform, the
       result is::

           <document name=\"top-level title">
               <title>
                   Top-Level Title
               <subtitle name="second-level title">
                   Second-Level Title
               <paragraph>
                   A paragraph.

       (Note that the implicit hyperlink target generated by the
       "Second-Level Title" is preserved on the "subtitle" element
       itself.)

    Any comment elements occurring before the document title or
    subtitle are accumulated and inserted as the first body elements
    after the title(s).

|#
(register-settings-spec
 '((:doctitle-xform boolean t
   "Apply transform promote document title and subtitle")
   (:docinfo-xform boolean t
    "Apply transform to create bibliographic fields")))

(defun first-child-not-type(node type)
  "Returns first child of node not of type type"
  (with-children(child node)
    (when (not (typep child type))
      (throw :skip-siblings child))))

(defclass doctitle(transform)
  ()
  (:default-initargs :priority 320)
  (:documentation
   "Transform to promote document title and subtitle."))

(defmethod transform((transform doctitle))
  (let ((document (document (node transform))))
    (when (setting :doctitle-xform document)
	(when (promote-document-title document)
	  (promote-document-subtitle document)))))

(defun rem-children(node)
  "Remove children from node and return them as a list"
  (nreverse
   (let ((children nil))
     (with-children(child node)
       (remove-node child)
       (push child children))
     children)))

(defun promote-document-title(document)
  (let ((section (candidate-node document)))
    (when section
      ;; Transfer the section's attributes to the document element (at
      ;; root)
      (with-attributes(k v section) (setf (attribute document k) v))
      ;; move title to  top of document
      (let ((title (child section 0)))
        (rem-child section 0)
        (add-child document title 0))
      ;; move section contents into document before section
      (add-child document (rem-children section) (index document section ))
      (remove-node section)
      t)))

(defun promote-document-subtitle(document)
  (let((subsection (candidate-node document)))
    (when subsection
      (let ((subtitle (make-node 'docutils.nodes::subtitle)))
	(with-attributes(k v subsection) (setf (attribute subtitle k) v))
	;;Transfer the contents of the subsection's title to the subtitle
	(let((title (child subsection 0)))
	  (remove-node title)
	  (add-child subtitle (rem-children title)))
	;; insert subtitle into document
	(add-child document subtitle 1)
	;; add subsection content into document
	(add-child document
		   (rem-children subsection)
		   (index document subsection))
	(remove-node subsection))
      t)))

(defun candidate-node(document)
  (let ((node (first-child-not-type document
				    '(or docutils.nodes:prebibliographic docutils.nodes:comment ))))
    (when (typep node 'docutils.nodes:section) node)))


#|

    This transform is specific to the reStructuredText_ markup syntax;
    see "Bibliographic Fields" in the `reStructuredText Markup
    Specification`_ for a high-level description. This transform
    should be run *after* the `DocTitle` transform.

    Given a field list as the first non-comment element after the
    document title and subtitle (if present), registered bibliographic
    field names are transformed to the corresponding DTD elements,
    becoming child elements of the "docinfo" element (except for a
    dedication and/or an abstract, which become "topic" elements after
    "docinfo").

    For example, given this document fragment after parsing::

        <document>
            <title>
                Document Title
            <field_list>
                <field>
                    <field_name>
                        Author
                    <field_body>
                        <paragraph>
                            A. Name
                <field>
                    <field_name>
                        Status
                    <field_body>
                        <paragraph>
                            $RCSfile: frontmatter.lisp,v $
            ...

    After running the bibliographic field list transform, the
    resulting document tree would look like this::

        <document>
            <title>
                Document Title
            <docinfo>
                <author>
                    A. Name
                <status>
                    frontmatter.py
            ...

    The "Status" field contained an expanded RCS keyword, which is
    normally (but optionally) cleaned up by the transform. The sole
    contents of the field body must be a paragraph containing an
    expanded RCS keyword of the form "$keyword: expansion text $". Any
    RCS keyword can be processed in any bibliographic field. The
    dollar signs and leading RCS keyword name are removed. Extra
    processing is done for the following RCS keywords:

    - "RCSfile" expands to the name of the file in the RCS or CVS
      repository, which is the name of the source file with a ",v"
      suffix appended. The transform will remove the ",v" suffix.

    - "Date" expands to the format "YYYY/MM/DD hh:mm:ss" (in the UTC
      time zone). The RCS Keywords transform will extract just the
      date itself and transform it to an ISO 8601 format date, as in
      "2000-12-31".

      (Since the source file for this text is itself stored under CVS,
      we can't show an example of the "Date" RCS keyword because we
      can't prevent any RCS keywords used in this explanation from
      being expanded. Only the "RCSfile" keyword is stable; its
      expansion text changes only if the file name changes.)
|#

(defvar *rcs-keyword-substitutions*
  '(("\\$Date: 2006/08/08 08:12:59 $" .
       "\\1-\\2-\\3")
    ("\\$RCSfile: frontmatter.lisp,v $" . "\\1")
    ("\\$[a-zA-z]+: (.+) \\$" . "\\1")))

(defclass docinfo(transform)
  ((biblio-nodes :initarg :biblio-nodes :reader biblio-nodes
    :initform
    '(("author" . docutils.nodes:author)
      ("authors" . docutils.nodes:authors)
      ("organization" . docutils.nodes:organization)
      ("address" . docutils.nodes:address)
      ("contact" . docutils.nodes:contact)
      ("version" . docutils.nodes:version)
      ("revision" . docutils.nodes:revision)
      ("status" . docutils.nodes:status)
      ("date" . docutils.nodes:date)
      ("copyright" . docutils.nodes:copyright)
      ("dedication" . docutils.nodes:topic)
      ("abstract" . docutils.nodes:topic))))
  (:default-initargs :priority 340)
  (:documentation
   "Transform to create document bibliographic fields."))

(defmethod transform((transform docinfo))
  (let ((document (document (node transform))))
    (when (setting :docinfo-xform document)
      (let ((candidate
             (first-child-not-type document
                                   '(or docutils.nodes:prebibliographic
                                     docutils.nodes:comment))))
        (when (typep candidate 'docutils.nodes:field-list)
          (let ((first-nontitular
                 (first-child-not-type document 'docutils.nodes:titular))
                (nodelist (extract-bibliographic candidate
                                                 (biblio-nodes transform))))
            (add-child document nodelist (index document first-nontitular))
            (remove-node candidate))))))) ;; remove untransformed field list

(defun clean-rcs-keywords(paragraph &optional
                          (substitutions *rcs-keyword-substitutions*))
  (when (= 1 (number-children paragraph))
    (let ((textnode (child paragraph 0)))
      (when (typep textnode 'docutils.nodes:text)
        (let ((data (as-text textnode)))
          (dolist(substitution substitutions)
            (when (cl-ppcre:scan (car substitution) data)
              (add-child
               paragraph
               (make-instance 'docutils.nodes:text :text
                              (cl-ppcre:regex-replace
                               (car substitution) data (cdr substitution)))
               0)
              (remove-node textnode)
              (return-from clean-rcs-keywords))))))))

(defun extract-bibliographic(field-list biblio-nodes)
  (let ((docinfo (make-node 'docutils.nodes:docinfo :line (line field-list)))
        (topics (list (list "dedication") (list "abstract"))))
    (with-children(field field-list)
      (let ((docutils:*current-line-number* (line field)))
        (handler-case
            (let* ((name (as-text (child (child field 0) 0)))
                   (canonical (canonical-text (normalise-name name)))
                   (biblioclass  (cdr (assoc canonical biblio-nodes
                                             :test #'string-equal))))
              (unless (and (= 2 (number-children field))
                           biblioclass
                           (check-empty-biblio-field field name))
                (error 'transform-condition))
              (cond
                ((subtypep biblioclass 'docutils.nodes:text-element)
                 (unless (check-compound-biblio-field field name)
                   (error 'transform-condition))
                 (let ((p (child (child field 1) 0)))
                   (clean-rcs-keywords p)
                   (remove-node p)
                   (add-child docinfo (make-node biblioclass p ))))
                ((subtypep biblioclass 'docutils.nodes:authors)
                 (extract-authors field name docinfo))
                ((subtypep biblioclass 'docutils.nodes:topic)
                 (let ((topic (assoc  canonical topics :test #'string-equal)))
                   (when (cdr topic)
                     (report :warning `("There can be only one ~S field." ,name)
                             :node field)
                     (error 'transform-error))
                   (let ((topicnode (make-node biblioclass :class canonical )))
                     (add-child topicnode
                                (make-node 'docutils.nodes:title
                                           (translated-text canonical)))
                     (add-child topicnode (rem-children (child field 1)))
                     (setf (cdr topic) topicnode))))
                (t (add-child docinfo
                              (make-node biblioclass
                                         (rem-children (child field 1)))))))
          (transform-condition()
            (let ((last (child field (1- (number-children field)))))
              (when (and (= 1 (number-children last))
                         (typep (child last 0) 'docutils.nodes:paragraph))
                (clean-rcs-keywords (child last 0))))
            (remove-node field)
            (add-child docinfo field)))))
    (append
     (when (> (number-children docinfo) 0) (list docinfo))
     (mapcar #'cdr topics))))

(defun check-empty-biblio-field(field name)
  (if (> (number-children (child field (1- (number-children field)))) 0)
      t
      (progn
        (report :warning `("Cannot extract empty bibliographic field ~s" ,name)
                :node field)
        nil)))

(defun check-compound-biblio-field(field name)
  (let ((last (child field (1- (number-children field)))))
    (cond
      ((> (number-children last) 1)
       (report :warning `("Cannot extract compound bibliographic field ~s" ,name)
	       :node field)
       nil)
      ((not (typep (child last 0) 'docutils.nodes:paragraph))
       (report :warning `("Cannot extractbibliographic field ~s containing anything other than a single paragraph" ,name)
	       :node field)
       nil)
      (t t))))

(defun extract-authors(field name docinfo)
  (declare (ignore name))
  (let ((value (child field 1)))
    (handler-case
        (let ((authornodes
               (mapcar
                #'(lambda(a) (make-node 'docutils.nodes:author a))
                (cond
                  ((/= (number-children value) 1)
                   (authors-from-paragraphs value))
                  ((let ((value (child value 0)))
                     (typecase value
                       (docutils.nodes:paragraph (authors-from-paragraph value))
                       (docutils.nodes:bullet-list
                        (authors-from-bullet-list value)))))
                  (t (error 'transform-condition))))))
          (cond
            ((> (length authornodes) 1)
             (add-child docinfo (make-node 'docutils.nodes:authors authornodes)))
            ((= (length authornodes) 1)
             (add-child docinfo (first authornodes)))
            (t (error 'transform-condition))))
      (transform-condition()
        (report :warning `("Bibliographic field ~s incompatible with
extraction: it must contain either a single paragraph (with authors
separated by one of ~A), multiple paragraphs (one per author), or a
bullet list with one paragraph (one author) per item" ,name
                           ,(author-separators))
                :node field)))))

(defun authors-from-paragraph(paragraph)
  (let ((text (strip (as-text (child paragraph 0)))))
    (when (= 0 (length text)) (error 'transform-condition))
    (mapcar #'(lambda(a) (make-node 'docutils.nodes:text (strip a)))
	    (or
	     (dolist(authorsep (author-separators))
	       (let ((authornames (split-sequence:split-sequence authorsep text)))
		 (when (> (length authornames) 1) (return authornames))))
	     (list text)))))

(defun authors-from-bullet-list(list)
  (let ((authors nil))
    (with-children(item list)
      (when (or (not (= (number-children item) 1))
		(not (typep (child item 0) 'docutils.nodes:paragraph)))
	(error 'transform-condition))
      (push (rem-children (child item 0)) authors))
    (unless authors (error 'transform-condition))
    (nreverse authors)))

(defun authors-from-paragraphs(value)
  (let ((authors nil))
    (with-children(p value)
      (unless (typep p 'docutils.nodes:paragraph)
	(error 'transform-condition))
      (push  (mapcar #'rem-children p) authors))
    (nreverse authors)))



